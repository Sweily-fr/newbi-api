# Types pour le système banking

type Transaction {
  id: ID!
  externalId: String!
  provider: BankingProvider!
  type: TransactionType!
  status: TransactionStatus!
  amount: Float!
  currency: String!
  description: String!
  category: String
  expenseCategory: ExpenseCategory
  fromAccount: String
  toAccount: String
  workspaceId: String!
  userId: ID!
  date: DateTime
  processedAt: DateTime
  failureReason: String
  fees: TransactionFees
  metadata: JSON
  receiptRequired: Boolean
  receiptFile: ReceiptFile
  # Champs de rapprochement bancaire
  linkedInvoiceId: ID
  linkedInvoice: LinkedInvoiceSummary
  linkedExpenseId: ID
  reconciliationStatus: ReconciliationStatusEnum
  reconciliationDate: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""
Résumé d'une facture liée à une transaction (évite les dépendances circulaires)
"""
type LinkedInvoiceSummary {
  id: ID!
  number: String
  status: String
  clientName: String
  totalTTC: Float
  issueDate: DateTime
  dueDate: DateTime
}

enum ReconciliationStatusEnum {
  UNMATCHED
  SUGGESTED
  MATCHED
  IGNORED
}

enum ExpenseCategory {
  OFFICE_SUPPLIES
  TRAVEL
  MEALS
  ACCOMMODATION
  SOFTWARE
  HARDWARE
  SERVICES
  MARKETING
  TAXES
  RENT
  UTILITIES
  SALARIES
  INSURANCE
  MAINTENANCE
  TRAINING
  SUBSCRIPTIONS
  OTHER
}

type ReceiptFile {
  url: String
  key: String
  filename: String
  mimetype: String
  size: Int
  uploadedAt: DateTime
}

type TransactionFees {
  amount: Float!
  currency: String!
  provider: String
}

type AccountBanking {
  id: ID!
  externalId: String!
  provider: BankingProvider!
  name: String!
  type: AccountType!
  status: AccountStatus!
  balance: AccountBalance!
  accountNumber: String
  routingNumber: String
  iban: String
  bic: String
  bankName: String!
  institutionName: String
  institutionLogo: String
  accountHolder: AccountHolder!
  workspaceId: String!
  userId: ID
  lastSyncAt: DateTime!
  notifications: AccountNotifications
  limits: AccountLimits
  transactionSync: TransactionSyncStatus
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""
Statut de synchronisation des transactions d'un compte
"""
type TransactionSyncStatus {
  """Date de la dernière synchronisation réussie"""
  lastSyncAt: DateTime
  """Statut de la synchronisation: pending, in_progress, complete, partial, failed"""
  status: TransactionSyncStatusEnum!
  """Nombre total de transactions synchronisées pour ce compte"""
  totalTransactions: Int!
  """Date de la transaction la plus ancienne récupérée"""
  oldestTransactionDate: DateTime
  """Date de la transaction la plus récente récupérée"""
  newestTransactionDate: DateTime
  """Message d'erreur si la dernière sync a échoué"""
  lastError: String
  """Historique des 10 dernières synchronisations"""
  history: [SyncHistoryEntry!]!
}

type SyncHistoryEntry {
  date: DateTime!
  status: String!
  transactionsCount: Int!
  duration: Int!
  error: String
}

enum TransactionSyncStatusEnum {
  PENDING
  IN_PROGRESS
  COMPLETE
  PARTIAL
  FAILED
}

type AccountBalance {
  available: Float!
  current: Float!
  currency: String!
}

type AccountHolder {
  name: String!
  email: String!
}

type AccountNotifications {
  lowBalance: LowBalanceNotification
  transactions: TransactionNotification
}

type LowBalanceNotification {
  enabled: Boolean!
  threshold: Float!
}

type TransactionNotification {
  enabled: Boolean!
}

type AccountLimits {
  daily: Float
  monthly: Float
  perTransaction: Float
}

type ApiMetric {
  id: ID!
  provider: BankingProvider!
  endpoint: String!
  method: String!
  requestCount: Int!
  successCount: Int!
  errorCount: Int!
  responseTime: ResponseTimeMetrics!
  cost: CostMetrics!
  date: DateTime!
  workspaceId: String!
  errors: [ApiError!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ResponseTimeMetrics {
  total: Float!
  average: Float!
  min: Float
  max: Float
}

type CostMetrics {
  total: Float!
  perRequest: Float!
  currency: String!
}

type ApiError {
  code: String!
  message: String!
  count: Int!
  lastOccurrence: DateTime!
}

type PaymentResult {
  transaction: Transaction!
  success: Boolean!
  message: String
}

type RefundResult {
  transaction: Transaction!
  success: Boolean!
  message: String
}

type ProviderStats {
  provider: BankingProvider!
  totalRequests: Int!
  totalCost: Float!
  avgResponseTime: Float!
  successRate: Float!
}

type CostComparison {
  provider: BankingProvider!
  totalCost: Float!
  totalRequests: Int!
  avgCostPerRequest: Float!
}

# Enums

enum BankingProvider {
  BRIDGE
  STRIPE
  PAYPAL
  MOCK
  MANUAL
}

enum TransactionType {
  PAYMENT
  REFUND
  TRANSFER
  WITHDRAWAL
  DEPOSIT
  CREDIT
  DEBIT
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

enum AccountType {
  CHECKING
  SAVINGS
  CREDIT
  LOAN
  BUSINESS
  INVESTMENT
  OTHER
}

enum AccountStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  CLOSED
}

# Inputs

input ProcessPaymentInput {
  amount: Float!
  currency: String!
  description: String!
  fromAccount: String!
  toAccount: String!
  beneficiaryName: String
  metadata: JSON
  idempotencyKey: String
}

input ProcessRefundInput {
  transactionId: ID!
  amount: Float
  reason: String
  metadata: JSON
}

input CreateAccountInput {
  type: AccountType!
  holderName: String!
  holderEmail: String!
  metadata: JSON
}

input UpdateAccountInput {
  notifications: AccountNotificationsInput
  limits: AccountLimitsInput
}

input AccountNotificationsInput {
  lowBalance: LowBalanceNotificationInput
  transactions: TransactionNotificationInput
}

input LowBalanceNotificationInput {
  enabled: Boolean!
  threshold: Float!
}

input TransactionNotificationInput {
  enabled: Boolean!
}

input AccountLimitsInput {
  daily: Float
  monthly: Float
  perTransaction: Float
}

input TransactionFiltersInput {
  type: TransactionType
  status: TransactionStatus
  minAmount: Float
  maxAmount: Float
  startDate: DateTime
  endDate: DateTime
  accountId: String
  sync: Boolean
}

input MetricsFiltersInput {
  provider: BankingProvider
  startDate: DateTime!
  endDate: DateTime!
}

"""
Input pour la synchronisation complète des transactions
Permet de spécifier une période et des options avancées
"""
input SyncAllTransactionsInput {
  """ID du compte spécifique à synchroniser (optionnel, tous les comptes si non spécifié)"""
  accountId: String
  """Date de début au format YYYY-MM-DD (défaut: 90 jours en arrière)"""
  since: String
  """Date de fin au format YYYY-MM-DD (défaut: aujourd'hui)"""
  until: String
  """Force une synchronisation complète sans limite de pages"""
  fullSync: Boolean
}

"""
Résultat détaillé d'une synchronisation de transactions
"""
type SyncAllTransactionsResult {
  success: Boolean!
  """Nombre total de comptes traités"""
  accounts: Int!
  """Nombre total de transactions synchronisées"""
  transactions: Int!
  """Nombre de comptes synchronisés avec succès"""
  successfulAccounts: Int!
  """Nombre de comptes en échec"""
  failedAccounts: Int!
  """Noms des comptes en échec"""
  failedAccountNames: [String!]!
  """Durée totale de la synchronisation en ms"""
  duration: Int
  """Période de synchronisation utilisée"""
  period: SyncPeriod
  """Détails par compte"""
  details: [AccountSyncDetail!]
}

type SyncPeriod {
  since: String!
  until: String!
}

type AccountSyncDetail {
  accountId: String!
  accountName: String!
  status: String!
  transactionsCount: Int!
  duration: Int!
  error: String
}

# Queries

extend type Query {
  # Transactions
  transactions(
    workspaceId: ID!
    filters: TransactionFiltersInput
    limit: Int
    offset: Int
  ): [Transaction!]!
  transaction(id: ID!): Transaction
  transactionByExternalId(
    provider: BankingProvider!
    externalId: String!
  ): Transaction

  # Comptes
  bankingAccounts(workspaceId: ID!): [AccountBanking!]!
  bankingAccount(id: ID!): AccountBanking
  accountBalance(accountId: String!): AccountBalance!

  # Métriques
  apiMetrics(filters: MetricsFiltersInput!): [ApiMetric!]!
  providerStats(
    provider: BankingProvider!
    startDate: DateTime!
    endDate: DateTime!
  ): ProviderStats
  costComparison(startDate: DateTime!, endDate: DateTime!): [CostComparison!]!

  # Historique
  transactionHistory(
    accountId: String!
    filters: TransactionFiltersInput
  ): [Transaction!]!
}

# Input pour créer une transaction manuelle
input CreateTransactionInput {
  workspaceId: ID!
  amount: Float!
  currency: String
  description: String!
  type: TransactionType!
  date: DateTime
  category: String
  vendor: String
  notes: String
  tags: [String!]
}

input UpdateTransactionInput {
  amount: Float
  currency: String
  description: String
  type: TransactionType
  date: DateTime
  category: String
  vendor: String
  notes: String
  tags: [String!]
}

# Mutations

extend type Mutation {
  # Transactions manuelles
  createTransaction(input: CreateTransactionInput!): Transaction!
  updateTransaction(id: ID!, input: UpdateTransactionInput!): Transaction!
  deleteTransaction(id: ID!): Boolean!

  # Paiements
  processPayment(input: ProcessPaymentInput!): PaymentResult!
  processRefund(input: ProcessRefundInput!): RefundResult!

  # Gestion des comptes
  createBankingAccount(input: CreateAccountInput!): AccountBanking!
  updateBankingAccount(id: ID!, input: UpdateAccountInput!): AccountBanking!
  deleteBankingAccount(id: ID!): Boolean!
  syncAccountBalance(accountId: String!): AccountBalance!

  # Administration
  switchBankingProvider(provider: BankingProvider!): Boolean!
  syncTransactionHistory(accountId: String!): [Transaction!]!

  """
  Synchronisation complète des transactions avec pagination et période configurable.
  Récupère TOUTES les transactions disponibles pour la période spécifiée.
  """
  syncAllTransactions(input: SyncAllTransactionsInput): SyncAllTransactionsResult!
}

# Subscriptions

extend type Subscription {
  transactionUpdated(workspaceId: String!): Transaction!
  accountBalanceUpdated(accountId: String!): AccountBalance!
  apiMetricsUpdated(workspaceId: String!): ApiMetric!
}
